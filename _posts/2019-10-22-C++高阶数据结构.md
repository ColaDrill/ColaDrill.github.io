---
layout:     post
title:      C++高阶数据结构
subtitle:   For dream, For love, For future
date:       2019-10-22
author:     Jiayue Cai
header-img: img/post-bg-arch_linux.png
catalog: true
tags:
    - C++

---


> Last updated on 2019-10-26...

趁着秋招刚结束的余热，写这篇博客一来为了复习跟备忘，二来为了督促自己学习。（弥补自己大一当时没坚持下来的遗憾...）

> 这边博客全部写完估计要一段比较长的时间，一起学习进步吧！

### 数学结构

#### Hash表

[【POJ 3349】Snowflake Snow Snowflakes](http://poj.org/problem?id=3349)

**题 意：**判断所有的雪花中是否有相似的。相似的判断依据就是其中某一雪花`从任意一位置顺时针或逆时针`按顺序组成6位数中的所有可能是否有与另一个雪花完全相同的，若有，则说明这两个雪花相似，否则不相似。而题目就是要据此条件判断所有的雪花中是否存在相似的雪花。

**分 析：**朴素的算法就是枚举，对任意两个雪花都进行这样的判断。这样的时间复杂度接近为O(n^2),而题目中n的最大值为100000，显然会超时，这里采用`哈希查找`的办法解决，并采用`链地址法`解决冲突。

**思 路：**若判断在该哈希位置已经存在雪花，那么不管是冲突的，还是本身key值相等的，统一用上面的方法对该哈希位置上的每一个雪花进行相似比较。若存在与其相似的雪花，则直接返回，主函数就不需要在对后续输入的雪花进行相似判断了，否则就将该雪花利用头插法（或尾插法）插入到该哈希位置的链表中。

```c#
#include <bits/stdc++.h>
using namespace std;

#define N 100001

typedef struct node{
    int data[6];
    struct node* last;
}point;

int n, dp[6];
point snow[N];

void init(){
    for(int i=0;i<N;i++) snow[i].last=NULL;
}

bool issame(int* white){
    for(int i=0;i<6;i++){    //这里为了解决同构的问题，我们必须要考虑顺时针和逆时针，在这里我们引入了如下的方法进行优化，值得学习 
        if((dp[0]==white[i] && dp[1]==white[(i+1)%6] && dp[2]==white[(i+2)%6] && 
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+4)%6] && dp[5]==white[(i+5)%6]) ||
            (dp[0]==white[i] && dp[1]==white[(i+5)%6] && dp[2]==white[(i+4)%6] &&
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+2)%6] && dp[5]==white[(i+1)%6]))
            return true;
    }
    return false;
}

bool find(int key){
    point* k=snow[key].last;
    while(k!=NULL){
        if(issame(k->data)) return true;
        k=k->last;
    }
    return false;
}

void insert(int key){
    point* k=new point;
    for(int i=0;i<6;i++) k->data[i]=dp[i];
    k->last=snow[key].last;
    snow[key].last=k;
}
 
int main(){
    bool ok=false;
    init();
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int sum=0;
        for(int j=0;j<6;j++) scanf("%d",&dp[j]),sum+=dp[j];
        sum=sum%N;
        if(find(sum)) ok=true;
        else insert(sum);
    }
    if(ok) printf("Twin snowflakes found.\n");
    else printf("No two snowflakes are alike.\n");
    return 0;
}
```


### 线性结构

例如数组、栈、队列、双端队列等，略


### 集合结构

#### 幷查集

并查集是若干个不相交集合，能够实现较快的`合并`和`判断`元素所在集合的操作。（eg.求无向图的连通分量个数、Kruskar算法求最小生成树）

**并查集的操作：**

1、Make_Set(x) 把每一个元素初始化为一个集合
- 初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。

2、Find_Set(x) 查找一个元素所在的集合
- 查找一个元素所在的集合，其精髓是找到这个元素所在集合的祖先！这个才是并查集判断和合并的最终依据。
- 判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。
- 合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。

3、Union(x,y) 合并x,y所在的两个集合
- 利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。

**并查集的优化：**

1、Find_Set(x)时 路径压缩
- 寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？
- 答案是肯定的，这就是路径压缩，即当我们经过`递推`找到祖先节点后，`回溯`的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了；可见，路径压缩方便了以后的查找。

2、Union(x,y)时 按秩合并
- 即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。

```c#
int father[MAX];   /* father[x]表示x的父节点*/
int rank[MAX];     /* rank[x]表示x的秩*/

/* 初始化集合*/
void Make_Set(int x){
    father[x] = x;   //根据实际情况指定的父节点可变化
    rank[x] = 0;    //根据实际情况初始化秩也有所变化
}

/* 查找x元素所在的集合,回溯时压缩路径*/
int Find_Set(int x){
    if (x != father[x])
        father[x] = Find_Set(father[x]); //这个回溯时的压缩路径是精华
    return father[x];
}

/* 按秩合并x,y所在的集合。下面的那个if else结构不是绝对的，具体根据情况变化。但是，宗旨是不变的即，按秩合并，实时更新秩。*/
void Union(int x, int y){
    x = Find_Set(x);
    y = Find_Set(y);
    if (x == y) return;
    if (rank[x] > rank[y]) 
        father[y] = x;
    else{
        if (rank[x] == rank[y])
            rank[y]++;
        father[x] = y;
    }
}
```

[【POJ 1182】食物链](http://poj.org/problem?id=1182)

**思 路：**把确定了相对关系的节点放在同一棵树中，每个节点对应的 r[]值记录他与根节点的关系：
- 0：同类
- 1：被父亲节点吃
- 2： 吃父亲节点

> [图解链接](https://blog.csdn.net/freezhanacmore/article/details/8767413)

```c#
#include <bits/stdc++.h>
using namespace std;

const int maxn = 50000+10;

int p[maxn]; //存父节点
int r[maxn];//存与父节点的关系 0 同一类，1被父节点吃，2吃父节点

void set(int n) //初始化{
    for(int x = 1; x <= n; x++){
        p[x] = x; //开始自己是自己的父亲节点
        r[x] = 0;//开始自己就是自己的父亲，每一个点均独立
    }
}

int find(int x) //找父亲节点{
    if(x == p[x]) return x;
    int t = p[x];
    p[x] = find(p[x]);
    r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系
    return p[x];
}

void Union(int x, int y, int d){
    int fx = find(x);
    int fy = find(y);
    p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父
    r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系
}

int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    set(n);
 
    int ans = 0;
    int d, x, y;
    while(m--){
        scanf("%d%d%d", &d, &x, &y);
        if(x > n || y > n || (d == 2 && x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎
        else if(find(x) == find(y)){ //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎
            if(d == 1 && r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类
            if(d == 2 && (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y (注意要对应Uinon(x, y)的情况，否则一路WA到死啊！！！)
        }
        else Union(x, y, d); //如果开始没有关系，则建立关系
    }
    printf("%d\n", ans);
    return 0;
}
```

> 其他：[【POJ 1308】Is It A Tree?](http://poj.org/problem?id=1308)、[【POJ 1611】The Suspects](http://poj.org/problem?id=1611)、[【POJ 1986】Distance Queries](http://poj.org/problem?id=1986)、[【POJ 1988】Cube Stacking](http://poj.org/problem?id=1988)


### 统计结构

#### 树状数组

[【POJ 2155】Matrix](http://poj.org/problem?id=2155)

**题 意：**提供一个M×N的矩阵，其中每一个格子中的数不是1就是0，开始时每个格子的值为0。
- 修改操作（C）：取反矩阵中的数字，给出矩阵的左上角坐标(x1,y1)和右下角的坐标(x2,y2)。
- 查询操作（Q）：查询第x行第y列的格子中的数子是什么。

**分 析：**根据这个题目中介绍的这个矩阵中的数的特点不是1就是0，这样我们只需记录每个格子改变过几次,即可判断这个格子的数字。

> [图解链接](https://wenku.baidu.com/view/1e51750abb68a98271fefaa8)

```c#
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1010;

int treeNum[MAXN][MAXN];

int lowbit(int x){
    return x&(-x);
}
 
long long getSum(int x , int y){
    long long sum = 0;
    for(int i = x ; i > 0 ; i -= lowbit(i))
        for(int j = y ; j > 0 ; j -= lowbit(j))
            sum += treeNum[i][j];
    return sum;
}
 
void add(int x , int y , int val){
    for(int i = x ; i < MAXN ; i += lowbit(i))
        for(int j = y ; j < MAXN ; j += lowbit(j))
            treeNum[i][j] += val;
}
 
void solve(int m){
    char ch;
    int x , y;
    int x1 , y1 , x2 , y2;
    memset(treeNum , 0 , sizeof(treeNum));
    while(m--){ 
        scanf("%c" , &ch); 
        if(ch == 'C'){
            scanf("%d%d" , &x1 , &y1);
            scanf("%d%d%*c" , &x2 , &y2);
            // update
            add(x1 , y1 , 1);
            add(x2+1 , y1 , -1);
            add(x1 , y2+1 , -1);
            add(x2+1 , y2+1 , 1);
        }
        else{
            scanf("%d%d%*c" , &x , &y);
            int ans = getSum(x , y);
            printf("%d\n" , ans%2);
        }
    }
}
 
int main(){
    int cas;
    int n , m;
    bool isFirst = true;
    scanf("%d" , &cas);
    while(cas){
        scanf("%d%d%*c" , &n , &m); 
        solve(m);
        if(--cas)
            puts("");
    }
    return 0;
}

```

#### 线段树

关于线段树节点维护的信息（以线保留型线段树为例）：
- cnt:保存的是当前节点被覆盖的值。（cnt信息不上传也不下传，属于线保留型。）
- sum:表示该节点控制的区域内，被覆盖的最大值。（由于初始cnt和sum都为0，所以可以用memset代替build）
- PushUp操作和update操作是必须的.


[【POJ 2482】Stars in Your Window](http://poj.org/problem?id=2482)

**题 意：**有很多点在二维平面内,每个点有一个价值,给你一个平行坐标轴的矩形,只可以移动矩形,问矩形最多能包括多少价值和的点.

**分 析：**本题首先要转换一下，我们用矩形的中心点来描述这个矩形，然后对于每个星星，我们建立一个矩形中心的活动范围，即矩形中心在该范围内活动就可以覆盖到该星星。

**思 路：**其实这个新矩形与原来的矩形长和宽都是相同的，所以我们要求的问题就变成了：任意一个区域(肯定也是矩形的)最多能被矩形覆盖的最大值。即假如有价值为5和价值为3的矩形覆盖了一个区域，但是不仅仅是边界相交，那么这片区域的价值为8。

> [图解链接](https://blog.csdn.net/u013480600/article/details/22670997)

```c#
#include <bits/stdc++.h>
using namespace std;

#define lson i*2,l,m
#define rson i*2+1,m+1,r
const int MAXN=20000+5;  //必须为2W,因为点有1W个,所以扫描线2W个,不同的Y坐标最多有2W个

int cnt[MAXN*4],sum[MAXN*4];
double Y[MAXN];
struct seg{
    double l,r,h;
    int d;
    seg(){}
    seg(double a,double b,double c,int d):l(a),r(b),h(c),d(d){}
    bool operator <(const seg&b)const{
        if(h == b.h) return d<b.d;
        return h<b.h;
    }
}ss[MAXN];
void PushUp(int i){
    sum[i]=max(sum[i*2],sum[i*2+1]) + cnt[i];
}
void update(int ql,int qr,int v,int i,int l,int r){
    if(ql<=l && r<=qr){
        cnt[i]+=v;
        sum[i]+=v;
        return ;
    }
    int m=(l+r)>>1;
    if(ql<=m) update(ql,qr,v,lson);
    if(m<qr) update(ql,qr,v,rson);
    PushUp(i);
}
int main(){
    int n;
    double w,h;
    while(scanf("%d%lf%lf",&n,&w,&h)==3){
        if(n==0){
            printf("0\n");
            continue;
        }
        double x,y;
        int val;
        int cnt_y=0,cnt_ss=0;//记录有多少个Y值和扫描线
        for(int i=1;i<=n;i++){
            scanf("%lf%lf%d",&x,&y,&val);
            ss[cnt_ss++] = seg(y-h/2,y+h/2,x-w/2,val);
            ss[cnt_ss++] = seg(y-h/2,y+h/2,x+w/2,-val);
            Y[cnt_y++] = y-h/2;
            Y[cnt_y++] = y+h/2;
        }
        sort(ss,ss+cnt_ss);
        sort(Y,Y+cnt_y);
        cnt_y = unique(Y,Y+cnt_y)-Y;
        int ans=0;
        memset(cnt,0,sizeof(cnt));
        memset(sum,0,sizeof(sum));
        for(int i=0;i<cnt_ss-1;i++){
            int ql=lower_bound(Y,Y+cnt_y,ss[i].l)-Y;
            int qr=lower_bound(Y,Y+cnt_y,ss[i].r)-Y-1;
            if(ql<=qr) update(ql,qr,ss[i].d,1,0,cnt_y-1);
            ans=max(ans,sum[1]);
        }
        printf("%d\n",ans);
    }
}
```



[【POJ 1151】Atlantis](http://poj.org/problem?id=1151)

**题 意：** 求n个矩形面积的并（1 <= n <= 100，坐标范围：0 <= x1 < x2 <= 100000;0 <= y1 < y2 <= 100000）。

**思 路：**提取出所有矩形的所有纵向边作为扫描线，从左往右扫描，
- 每处理一条扫描线时，下一条扫描线与当前扫描线的距离乘上当前已覆盖纵向边的长度是一个部分面积，将这些面积累加起来就是n个矩形面积的并。
- 当前覆盖到纵向边长度可通过线段树来维护。

空间上要求先对所有点的纵坐标进行离散化，总时间复杂度为O(nlogn)。

```c#
#include <bits/stdc++.h>
using namespace std;

#define lc (o<<1)
#define rc ((o<<1)+1)
 
const int MAXN = 100 + 10;
 
double y[MAXN<<1];
int cnt;
 
struct Scanline {
    double x;
    double y1, y2;
    bool is_left;
    bool operator < (const Scanline& e) const {
        return x < e.x;
    }
} scanlines[MAXN<<1];
 
struct Node {
    int L, R;
    double len;
    int cover;
} nodes[MAXN<<3];
 
int point_to(double x) {
    return lower_bound(y, y + cnt, x) - y;
}
 
void build(int o, int L, int R) {
    nodes[o].L = L;
    nodes[o].R = R;
    nodes[o].len = 0;
    nodes[o].cover = 0;
    if(L + 1 == R) return;
    int M = (L + R) >> 1;
    build(lc, L, M);
    build(rc, M, R);
}
 
void maintain_len(int o) {
    if(nodes[o].cover > 0)
        nodes[o].len = y[nodes[o].R] - y[nodes[o].L];
    else if(nodes[o].L + 1 == nodes[o].R) 
        nodes[o].len = 0;
    else
        nodes[o].len = nodes[lc].len + nodes[rc].len;
}
 
void my_insert(int o, int ql, int qr) {
    if(ql <= nodes[o].L && nodes[o].R <= qr) {
        nodes[o].cover++;
        maintain_len(o);
        return;
    }
    int M = (nodes[o].L + nodes[o].R) >> 1;
    if(ql < M) my_insert(lc, ql, qr);
    if(qr > M) my_insert(rc, ql, qr);
    maintain_len(o);
}
 
void my_delete(int o, int ql, int qr) {
    if(ql <= nodes[o].L && nodes[o].R <= qr) {
        nodes[o].cover--;
        maintain_len(o);
        return;
    }
    int M = (nodes[o].L + nodes[o].R) >> 1;
    if(ql < M) my_delete(lc, ql, qr);
    if(qr > M) my_delete(rc, ql, qr);
    maintain_len(o);
}
 
int main(){
    int n, kase = 0;
    double x1, y1, x2, y2;
    while(scanf("%d", &n) == 1 && n) {
        for(int i = 0; i < n; i++) {
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            scanlines[i<<1].x = x1;
            scanlines[i<<1].y1 = y1;
            scanlines[i<<1].y2 = y2;
            scanlines[i<<1].is_left = true;
            scanlines[(i<<1)+1].x = x2;
            scanlines[(i<<1)+1].y1 = y1;
            scanlines[(i<<1)+1].y2 = y2;
            scanlines[(i<<1)+1].is_left = false;
            y[i<<1] = y1;
            y[(i<<1)+1] = y2;
        }
 
        sort(y, y + 2*n);
        cnt = unique(y, y + 2*n) - y;
 
        sort(scanlines, scanlines + 2*n);
        build(1, 0, cnt-1);
        double area = 0;
        for(int i = 0; i < 2*n-1; i++) {
            if(scanlines[i].is_left)
                my_insert(1, point_to(scanlines[i].y1), point_to(scanlines[i].y2));
            else
                my_delete(1, point_to(scanlines[i].y1), point_to(scanlines[i].y2));
            area += (scanlines[i+1].x - scanlines[i].x) * nodes[1].len;
        }
        printf("Test case #%d\n", ++kase);
        printf("Total explored area: %.2f\n\n", area);
    }
    return 0;
}
```

### 字符结构

#### 前缀树

#### 后缀树

#### 后缀数组



### 树状结构

#### AVL树

#### splay树（伸展树）

#### Treap

#### Cartesian Tree

#### Size Balance Tree


### 堆型结构

![](/img/post/20191022/1.png)

#### 左偏堆

> https://blog.csdn.net/theprinceofelf/article/details/7247454

#### 斜堆

#### 可合并堆

【POJ 3016】

【POJ 3666】


### 图形结构

#### 邻接矩

#### 阵邻接表

#### 十字链表

#### 邻接多重表








