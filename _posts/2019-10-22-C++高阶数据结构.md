---
layout:     post
title:      C++高阶数据结构
subtitle:   For Google
date:       2019-10-22
author:     Jiayue Cai
header-img: img/post-bg-arch_linux.png
catalog: true
tags:
    - C++

---


> Last updated on 2019-10-23...

趁着秋招刚结束的余热，写这篇博客一来为了复习跟备忘，二来为了督促自己学习。（弥补自己大一当时没坚持下来的遗憾...）

> 这边博客全部写完估计要一段比较长的时间，一起学习进步吧！

### 数学结构

#### Hash表

[【POJ 3349】Snowflake Snow Snowflakes](http://poj.org/problem?id=3349)

题意：判断所有的雪花中是否有相似的。相似的判断依据就是其中某一雪花从任意一位置顺时针或逆时针按顺序组成6位数中的所有可能是否有与另一个雪花完全相同的，若有，则说明这两个雪花相似，否则不相似。而题目就是要据此条件判断所有的雪花中是否存在相似的雪花。

分析：朴素的算法就是枚举，对任意两个雪花都进行这样的判断。这样的时间复杂度接近为O（n^2),而题目中n的最大值为100000，显然会超时，这里采用哈希查找的办法解决，并采用链地址法解决冲突。

解决：若判断在该哈希位置已经存在雪花，那么不管是冲突的，还是本身key值相等的，统一用上面的方法对该哈希位置上的每一个雪花进行相似比较。若存在与其相似的雪花，则直接返回，主函数就不需要在对后续输入的雪花进行相似判断了，否则就将该雪花利用头插法（或尾插法）插入到该哈希位置的链表中。

```c#
#include <bits/stdc++.h>
using namespace std;
#define N 100001

typedef struct node{
    int data[6];
    struct node* last;
}point;

int n, dp[6];
point snow[N];

void init(){
    for(int i=0;i<N;i++) snow[i].last=NULL;
}

bool issame(int* white){
    for(int i=0;i<6;i++){    //这里为了解决同构的问题，我们必须要考虑顺时针和逆时针，在这里我们引入了如下的方法进行优化，值得学习 
        if((dp[0]==white[i] && dp[1]==white[(i+1)%6] && dp[2]==white[(i+2)%6] && 
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+4)%6] && dp[5]==white[(i+5)%6]) ||
            (dp[0]==white[i] && dp[1]==white[(i+5)%6] && dp[2]==white[(i+4)%6] &&
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+2)%6] && dp[5]==white[(i+1)%6]))
            return true;
    }
    return false;
}

bool find(int key){
    point* k=snow[key].last;
    while(k!=NULL){
        if(issame(k->data)) return true;
        k=k->last;
    }
    return false;
}

void insert(int key){
    point* k=new point;
    for(int i=0;i<6;i++) k->data[i]=dp[i];
    k->last=snow[key].last;
    snow[key].last=k;
}
 
int main(){
    bool ok=false;
    init();
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int sum=0;
        for(int j=0;j<6;j++) scanf("%d",&dp[j]),sum+=dp[j];
        sum=sum%N;
        if(find(sum)) ok=true;
        else insert(sum);
    }
    if(ok) printf("Twin snowflakes found.\n");
    else printf("No two snowflakes are alike.\n");
    return 0;
}
```

### 线性结构

例如数组、栈、队列、双端队列等，略


### 集合结构

#### 幷查集

【POJ 1182】、【POJ 1308】、【POJ 1611】、【POJ 1986】、【POJ 1988】



### 统计结构

#### 树状数组

【POJ 2155】

#### 线段树

【POJ 2482】

【POJ 1151】



### 字符结构

#### 前缀树

#### 后缀树

#### 后缀数组



### 树状结构

#### AVL树

#### splay树（伸展树）

#### Treap

#### Cartesian Tree

#### Size Balance Tree


### 堆型结构

#### 左偏堆

> https://blog.csdn.net/theprinceofelf/article/details/7247454

#### 斜堆

#### 可合并堆

【POJ 3016】

【POJ 3666】


### 图形结构

#### 邻接矩

#### 阵邻接表

#### 十字链表

#### 邻接多重表








