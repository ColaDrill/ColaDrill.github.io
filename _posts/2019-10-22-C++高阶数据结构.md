---
layout:     post
title:      C++高阶数据结构
subtitle:   For dream
date:       2019-10-22
author:     Jiayue Cai
header-img: img/post-bg-arch_linux.png
catalog: true
tags:
    - C++

---


> Last updated on 2019-10-25...

趁着秋招刚结束的余热，写这篇博客一来为了复习跟备忘，二来为了督促自己学习。（弥补自己大一当时没坚持下来的遗憾...）

> 这边博客全部写完估计要一段比较长的时间，一起学习进步吧！

### 数学结构

#### Hash表

[【POJ 3349】Snowflake Snow Snowflakes](http://poj.org/problem?id=3349)

**题 意：**判断所有的雪花中是否有相似的。相似的判断依据就是其中某一雪花`从任意一位置顺时针或逆时针`按顺序组成6位数中的所有可能是否有与另一个雪花完全相同的，若有，则说明这两个雪花相似，否则不相似。而题目就是要据此条件判断所有的雪花中是否存在相似的雪花。

**分 析：**朴素的算法就是枚举，对任意两个雪花都进行这样的判断。这样的时间复杂度接近为O(n^2),而题目中n的最大值为100000，显然会超时，这里采用`哈希查找`的办法解决，并采用`链地址法`解决冲突。

**解 决：**若判断在该哈希位置已经存在雪花，那么不管是冲突的，还是本身key值相等的，统一用上面的方法对该哈希位置上的每一个雪花进行相似比较。若存在与其相似的雪花，则直接返回，主函数就不需要在对后续输入的雪花进行相似判断了，否则就将该雪花利用头插法（或尾插法）插入到该哈希位置的链表中。

```c#
#include <bits/stdc++.h>
using namespace std;
#define N 100001

typedef struct node{
    int data[6];
    struct node* last;
}point;

int n, dp[6];
point snow[N];

void init(){
    for(int i=0;i<N;i++) snow[i].last=NULL;
}

bool issame(int* white){
    for(int i=0;i<6;i++){    //这里为了解决同构的问题，我们必须要考虑顺时针和逆时针，在这里我们引入了如下的方法进行优化，值得学习 
        if((dp[0]==white[i] && dp[1]==white[(i+1)%6] && dp[2]==white[(i+2)%6] && 
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+4)%6] && dp[5]==white[(i+5)%6]) ||
            (dp[0]==white[i] && dp[1]==white[(i+5)%6] && dp[2]==white[(i+4)%6] &&
            dp[3]==white[(i+3)%6] && dp[4]==white[(i+2)%6] && dp[5]==white[(i+1)%6]))
            return true;
    }
    return false;
}

bool find(int key){
    point* k=snow[key].last;
    while(k!=NULL){
        if(issame(k->data)) return true;
        k=k->last;
    }
    return false;
}

void insert(int key){
    point* k=new point;
    for(int i=0;i<6;i++) k->data[i]=dp[i];
    k->last=snow[key].last;
    snow[key].last=k;
}
 
int main(){
    bool ok=false;
    init();
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int sum=0;
        for(int j=0;j<6;j++) scanf("%d",&dp[j]),sum+=dp[j];
        sum=sum%N;
        if(find(sum)) ok=true;
        else insert(sum);
    }
    if(ok) printf("Twin snowflakes found.\n");
    else printf("No two snowflakes are alike.\n");
    return 0;
}
```


### 线性结构

例如数组、栈、队列、双端队列等，略


### 集合结构

#### 幷查集

并查集是若干个不相交集合，能够实现较快的`合并`和`判断`元素所在集合的操作。（eg.求无向图的连通分量个数、Kruskar算法求最小生成树）

**并查集的操作：**

1、Make_Set(x) 把每一个元素初始化为一个集合
- 初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。

2、Find_Set(x) 查找一个元素所在的集合
- 查找一个元素所在的集合，其精髓是找到这个元素所在集合的祖先！这个才是并查集判断和合并的最终依据。
- 判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。
- 合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。

3、Union(x,y) 合并x,y所在的两个集合
- 利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。

**并查集的优化：**

1、Find_Set(x)时 路径压缩
- 寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？
- 答案是肯定的，这就是路径压缩，即当我们经过`递推`找到祖先节点后，`回溯`的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了；可见，路径压缩方便了以后的查找。

2、Union(x,y)时 按秩合并
- 即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。

```c#
int father[MAX];   /* father[x]表示x的父节点*/
int rank[MAX];     /* rank[x]表示x的秩*/

/* 初始化集合*/
void Make_Set(int x){
    father[x] = x;   //根据实际情况指定的父节点可变化
    rank[x] = 0;    //根据实际情况初始化秩也有所变化
}

/* 查找x元素所在的集合,回溯时压缩路径*/
int Find_Set(int x){
    if (x != father[x])
        father[x] = Find_Set(father[x]); //这个回溯时的压缩路径是精华
    return father[x];
}

/* 按秩合并x,y所在的集合。下面的那个if else结构不是绝对的，具体根据情况变化。但是，宗旨是不变的即，按秩合并，实时更新秩。*/
void Union(int x, int y){
    x = Find_Set(x);
    y = Find_Set(y);
    if (x == y) return;
    if (rank[x] > rank[y]) 
        father[y] = x;
    else{
        if (rank[x] == rank[y])
            rank[y]++;
        father[x] = y;
    }
}
```

[【POJ 1182】食物链](http://poj.org/problem?id=1182)

解题思路：[https://blog.csdn.net/freezhanacmore/article/details/8767413](https://blog.csdn.net/freezhanacmore/article/details/8767413)

```c#
#include <bits/stdc++.h>
using namespace std;
const int maxn = 50000+10;

int p[maxn]; //存父节点
int r[maxn];//存与父节点的关系 0 同一类，1被父节点吃，2吃父节点

void set(int n) //初始化{
    for(int x = 1; x <= n; x++){
        p[x] = x; //开始自己是自己的父亲节点
        r[x] = 0;//开始自己就是自己的父亲，每一个点均独立
    }
}

int find(int x) //找父亲节点{
    if(x == p[x]) return x;
    int t = p[x];
    p[x] = find(p[x]);
    r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系
    return p[x];
}

void Union(int x, int y, int d){
    int fx = find(x);
    int fy = find(y);
    p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父
    r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系
}

int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    set(n);
 
    int ans = 0;
    int d, x, y;
    while(m--){
        scanf("%d%d%d", &d, &x, &y);
        if(x > n || y > n || (d == 2 && x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎
        else if(find(x) == find(y)){ //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎
            if(d == 1 && r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类
            if(d == 2 && (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y (注意要对应Uinon(x, y)的情况，否则一路WA到死啊！！！)
        }
        else Union(x, y, d); //如果开始没有关系，则建立关系
    }
    printf("%d\n", ans);
    return 0;
}
```

> 其他：[【POJ 1308】Is It A Tree?](http://poj.org/problem?id=1308)、[【POJ 1611】The Suspects](http://poj.org/problem?id=1611)、[【POJ 1986】Distance Queries](http://poj.org/problem?id=1986)、[【POJ 1988】Cube Stacking](http://poj.org/problem?id=1988)


### 统计结构

#### 树状数组

【POJ 2155】

#### 线段树

【POJ 2482】

【POJ 1151】



### 字符结构

#### 前缀树

#### 后缀树

#### 后缀数组



### 树状结构

#### AVL树

#### splay树（伸展树）

#### Treap

#### Cartesian Tree

#### Size Balance Tree


### 堆型结构

![](/img/post/20191022/1.png)

#### 左偏堆

> https://blog.csdn.net/theprinceofelf/article/details/7247454

#### 斜堆

#### 可合并堆

【POJ 3016】

【POJ 3666】


### 图形结构

#### 邻接矩

#### 阵邻接表

#### 十字链表

#### 邻接多重表








