---
layout:     post
title:      搜索的原理
subtitle:   The principle of "search"
date:       2019-03-29
author:     Jiayue Cai
header-img: img/post-bg-black.jpg
catalog: true
tags:
    - Search
    - C++
---

> Last updated on 2019-03-29... 未完待续

> [参考链接](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962107&idx=1&sn=2704e234ccace7e3163dc7dbb46ca2e6&chksm=bd2d0f278a5a863180ef23737acd29759ce309568a27af2a1be144632b501b009109f012cc98&mpshare=1&scene=23&srcid=#rd)

### 核心结构

![](/img/post/20190329/1.png)

- 核心数据主要分为两部分（紫色部分）：web网页库、index索引数据。
- spider和search&index是相对工程的系统
- rank是和业务、策略紧密、算法相关的系统，搜索体验的差异主要在此，而业务、策略的优化是需要时间积累的

#### spider爬虫

- spider把互联网网页抓过来
- spider把互联网网页存储到网页库中（这个对存储的要求很高，要存储几乎整个“万维网”的镜像）

#### search&index索引与查询

建立索引与查询索引系统，这个系统又主要分为两部分：

一部分用于生成索引数据`build_index`
- build_index从网页库中读取数据，完成分词
- build_index生成倒排索引

一部分用于查询索引数据`search_index`
- search_index获得用户的搜索词，完成分词
- search_index查询倒排索引，获得“字符匹配”网页，这是初筛的结果

> [正/倒排索引](https://coladrill.github.io/2019/02/25/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%8A%80%E6%9C%AF/)

#### rank打分排序

输入：用户的搜索词。输出：排好序的第一页检索结果。
- rank对初筛的结果进行打分排序
- rank对排序后的第一页结果返回

### 检索的过程

> 分词、查倒排索引、求结果集交集

假设搜索词是“我爱”：

1、分词，“我爱”会分词为{我，爱}，时间复杂度为O(1)

2、每个分词后的item，从倒排索引查询包含这个item的网页list<url>，时间复杂度也是O(1)
- 我 -> {url1, url2}
- 爱 -> {url1, url2}

3、求list<url>的交集，就是符合所有查询词的结果网页，对于这个例子，{url1, url2}就是最终的查询结果

> 分词和倒排查询时间复杂度都是O(1)，整个搜索的时间复杂度取决于“求list<url>的交集”，问题转化为了求**两个集合交集**。

### 有序集合求交集交集

#### 两层for O(n<sup>2</sup>)

每个搜索词命中的网页是很多的，O(n*n)的复杂度是明显不能接受的。倒排索引是在创建之初可以进行排序预处理，问题转化成两个有序的list求交集，就方便多了。

#### 拉链法 O(n*n)

**前提：有序list求交集**

![](/img/post/20190329/2.png)

两个指针指向首元素，比较元素的大小：
- 如果相同，放入结果集，随意移动一个指针
- 否则，移动值较小的一个指针，直到队尾

这种方法的好处是：
- 集合中的元素最多被比较一次，时间复杂度为O(n)
- 多个有序集合可以同时进行，这适用于多个分词的item求url_id交集

> 这个方法就像一条拉链的两边齿轮，一一比对就像拉链，故称为拉链法。
> 倒排索引是提前初始化的，可以利用“有序”这个特性。

#### 分桶并行优化

数据量大时，url_id分桶水平切分+并行运算是一种常见的优化方法。

如果能将list1<url_id>和list2<url_id>分成若干个桶区间，每个区间利用多线程并行求交集，各个线程结果集的并集，作为最终的结果集，能够大大的减少执行时间。

	举例：
	有序集合1{1,3,5,7,8,9, 10,30,50,70,80,90}
	有序集合2{2,3,4,5,6,7, 20,30,40,50,60,70}
	
	求交集，先进行分桶拆分：
	桶1的范围为[1, 9]
	桶2的范围为[10, 100]
	桶3的范围为[101, max_int]
	
	于是：
	集合1就拆分成
	集合a{1,3,5,7,8,9}
	集合b{10,30,50,70,80,90}
	集合c{}
	
	集合2就拆分成
	集合d{2,3,4,5,6,7}
	集合e{20,30,40,50,60,70}
	集合e{}
	
	每个桶内的数据量大大降低了，并且每个桶内没有重复元素，可以利用多线程并行计算：
	桶1内的集合a和集合d的交集是x{3,5,7}
	桶2内的集合b和集合e的交集是y{30, 50, 70}
	桶3内的集合c和集合d的交集是z{}
	
	最终，集合1和集合2的交集，是x与y与z的并集，即集合{3,5,7,30,50,70}。

> 多线程、水平切分都是常见的优化手段。

#### bitmap再次优化 O(n)

数据进行了水平分桶拆分之后，每个桶内的数据一定处于一个范围之内，如果集合符合这个特点，就可以使用bitmap来表示集合：
![](/img/post/20190329/3.png)

如上图，假设set1{1,3,5,7,8,9}和set2{2,3,4,5,6,7}的所有元素都在桶值[1, 16]的范围之内，可以用16个bit来描述这两个集合。

原集合中的元素x，在这个16bitmap中的第x个bit为1，此时两个bitmap求交集，只需要将两个bitmap进行“与”操作，结果集bitmap的3，5，7位是1，表明原集合的交集为{3,5,7}。

水平分桶，bitmap优化之后，能极大提高求交集的效率，但时间复杂度仍旧是O(n)。bitmap需要大量连续空间，占用内存较大。

> bitmap能够表示集合，用它求集合交集速度非常快。

#### skiplist跳表 O(log(n))

> 有序链表集合求交集，跳表是最常用的数据结构，它可以将有序集合求交集的复杂度由O(n)降至接近O(log(n))。

要求交集，如果用拉链法，会发现1,2,3,4,20,21,22,23都要被无效遍历一次，每个元素都要被比对，时间复杂度为O(n)，能不能每次比对“跳过一些元素”呢？

跳表就出现了：
![](/img/post/20190329/4.png)

- 集合1{1,2,3,4,20,21,22,23,50,60,70}建立跳表时，一级只有{1,20,50}三个元素，二级与普通链表相同。
- 集合2{50,70}由于元素较少，只建立了一级普通链表。

如此这般，在实施“拉链”求交集的过程中，set1的指针能够由1跳到20再跳到50，中间能够跳过很多元素，无需进行一一比对，跳表求交集的时间复杂度近似O(log(n))，这是搜索引擎中常见的算法。

### 搜索架构发展







