---
layout:     post
title:      PyTorch基础
subtitle:   For Deep Learning
date:       2018-10-19
author:     Jiayue Cai
header-img: img/post-bg-black.jpg
catalog: true
tags:
    - PyTorch
    - Deep Learning
---


>>Last updated on 2018-10-19... 

- [PyTorch文档](https://pytorch.org/docs/stable/torch.html)

PyTorch是Torch的python版本，早期Torch是基于Lua语言的。相比tensorflow来说，其底层更亲民一些，也更适合动态的网络。

下面代码转载自[莫烦的课程](https://morvanzhou.github.io/tutorials/machine-learning/torch/)，个人根据自己的理解做了一写改动跟注释。
	
### numpy与tensor的转换

```python
import torch
import numpy as np

np_data = np.arange(6).reshape((2, 3))   #numpy数组
torch_data = torch.from_numpy(np_data)   #numpy数组转tensor
tensor2array = torch_data.numpy()        #tensor转numpy数组

print(
    'numpy array:\n', np_data,          # [[0 1 2], [3 4 5]]
    'torch tensor:\n', torch_data,      #   0 1 2 \n 3 4 5    [torch.LongTensor of size 2x3]
    'tensor to array:\n', tensor2array, # [[0 1 2], [3 4 5]]
)
```

### 矩阵点乘

```python
data = [[1,2], [3,4]]
tensor = torch.FloatTensor(data)  # 转换成32位浮点 tensor

print(
    'matrix multiplication (matmul)\n',
    'numpy: ', np.matmul(data, data)\n,     # [[7, 10], [15, 22]]
    'torch: ', torch.mm(tensor, tensor)\n   # [[7, 10], [15, 22]]
)
```

### 变量`Variable`

在 Torch 中的 Variable 就是一个存放会变化的值的地理位置. 里面的值会不停的变化

Variable 计算时, 它会在后台搭建计算图（computational graph），将所有的计算步骤 (节点) 都连接起来, 最后进行误差反向传递的时候, 一次性将所有 variable 里面的修改幅度 (梯度) 都计算出来

```python
import torch
from torch.autograd import Variable  # torch 中 Variable 模块

# 先定义 tensor
tensor = torch.FloatTensor([[1,2],[3,4]])

# 把 tensor 放到 Variable 里
variable = Variable(tensor, requires_grad=True)  #requires_grad表示是否参与误差反向传播, 是否要计算梯度
```

```python
print(tensor)
```

	1  2
	3  4
	[torch.FloatTensor of size 2x2]

```python
print(variable)
```

	Variable containing:
	1  2
	3  4
	[torch.FloatTensor of size 2x2]

### 计算梯度

```python
t_out = torch.mean(tensor*tensor)       # x^2
v_out = torch.mean(variable*variable)   # x^2
print(t_out)
print(v_out)    # 7.5

v_out.backward()    # 模拟 v_out 的误差反向传递

```

- Variable 是计算图的一部分, 用来传递误差
- v_out = 1/4 * sum(variable*variable) 这是计算图中的 v_out 计算步骤
- 针对于 v_out 的梯度就是, d(v_out)/d(variable) = 1/4*2*variable = variable/2

```python
print(variable.grad)    # 初始 Variable 的梯度
```

	0.5000  1.0000
	1.5000  2.0000


### 获取变量里的数据

直接print(variable)只会输出 Variable 形式的数据, 在很多时候是用不了的(比如想要用 plt 画图), 所以我们要转换一下, 将它变成 tensor 形式


```python
print(variable)     #  Variable 形式
```

	Variable containing:
	1  2
	3  4
	[torch.FloatTensor of size 2x2]

```python
print(variable.data)    # tensor 形式
```

	1  2
	3  4
	[torch.FloatTensor of size 2x2]

```python
print(variable.data.numpy())    # numpy 形式
```

	[[ 1.  2.]
	[ 3.  4.]]

### 4种激励函数

```python
import torch
import torch.nn.functional as F     # 激励函数都在这
from torch.autograd import Variable

# 做一些假数据来观看图像
x = torch.linspace(-5, 5, 200)  # x data (tensor), shape=(100, 1)
x = Variable(x)
x_np = x.data.numpy()   # 换成 numpy array, 出图时用

# 常用的激励函数
y_relu = F.relu(x).data.numpy()
y_sigmoid = F.sigmoid(x).data.numpy()
y_tanh = F.tanh(x).data.numpy()
y_softplus = F.softplus(x).data.numpy()
# y_softmax = F.softmax(x)  softmax 比较特殊, 不能直接显示, 不过他是关于概率的, 用于分类

# 画图
import matplotlib.pyplot as plt

plt.figure(1, figsize=(8, 6))
plt.subplot(221)
plt.plot(x_np, y_relu, c='red', label='relu')
plt.ylim((-1, 5))
plt.legend(loc='best')

plt.subplot(222)
plt.plot(x_np, y_sigmoid, c='red', label='sigmoid')
plt.ylim((-0.2, 1.2))
plt.legend(loc='best')

plt.subplot(223)
plt.plot(x_np, y_tanh, c='red', label='tanh')
plt.ylim((-1.2, 1.2))
plt.legend(loc='best')

plt.subplot(224)
plt.plot(x_np, y_softplus, c='red', label='softplus')
plt.ylim((-0.2, 6))
plt.legend(loc='best')

plt.show()
```
![af](https://morvanzhou.github.io/static/results/torch/2-3-1.png)


