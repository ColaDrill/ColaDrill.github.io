---
layout:     post
title:      C++刷题语句注记
subtitle:   For 笔试
date:       2018-08-18
author:     Jiayue Cai
header-img: img/post-bg-debug.png
catalog: true
tags:
    - C++

---


>Last updated on 2018-9-5...

### 刷题trick集合

数	组：[ij前后指针](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/)、下标对应存count

[链	表](https://blog.csdn.net/zqxnum1/article/details/48156913)：快慢指针、三指针

[二叉树](https://www.jianshu.com/p/35b07dbcdf73)：递归遍历、非递归遍历(stack)、层次遍历(queue)、[卡特兰数(二叉查找树个数)](https://blog.csdn.net/qqxx6661/article/details/76285972)

矩	阵：

### 容器库

[>> c++ list, vector, map, set 区别与用法比较](https://cloud.tencent.com/developer/article/1052125)

#### 关联 [Map](https://zh.cppreference.com/w/cpp/container/map)

为了实现快速查找，map内部本身就是按序存储的（比如[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)）。
在我们插入<key, value>键值对时，就会按照key的大小顺序进行存储。根据key值快速查找记录，查找的复杂度基本是Log(N)。
```c#
#include <map>
unordered_map<char, int> mp{    //因为这段未用到map自动排序功能，所以unordered_map就行
    {'a', 1},
    {'b', 2}, 
    {'c', 3},
 };
char c; int sum = 0;
if (mp.count(c)){               //count函数:返回拥有关键 key 的元素数（更常用）
	sum += mp.find(c)->second;  //find函数:按key查找，返回的是指针
		                            //若没找到则返回end()；也可写成(*mp.find(c)).second
									
//其他：
map<char,int> m1;                       //默认从小到大排序
map<char,int,   less<char>> m1;         //从小到大
map<char,int,greater<char>> m1;         //从大到小
m1.insert ( pair<char,int>('c',30) );	//插入
```
关联容器对比：
- set：唯一键的集合，按照键排序 
- map：键值对的集合，按照键排序，键是唯一的 
- multiset：键的集合，按照键排序 
- multimap：键值对的集合，按照键排序 
	
#### 队列 [queue](https://zh.cppreference.com/w/cpp/header/queue)

一种FIFO（先进先出）数据结构（>>另：[优先队列](https://blog.csdn.net/c20182030/article/details/70757660)）
![queue](https://upload-images.jianshu.io/upload_images/13187322-b03953abecbc6231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609/format/webp)
```c#
queue<int> q; //普通的先进先出队列
q.size(); //返回q里元素个数     q.empty();//返回q是否为空，空则返回1，否则返回0
q.push(k);//在q的末尾插入k      q.pop();  //删掉q的第一个元素
q.top();  //返回q的第一个元素   q.back(); //返回q的末尾元素

priority_queue<int> q1;                              //优先队列，默认大顶堆（less<int>）
priority_queue<int, vector<int>, less<int> > q1;     //top+pop出来：14 12 10 8 6 大到小
priority_queue<int, vector<int>, greater<int> > q2;  //top+pop出来：6 8 10 12 14 小到大
                                                     //形参依次为数据类型、保存数据的容器、元素比较方式
```
#### 栈 [stack](https://zh.cppreference.com/w/cpp/container/stack)

一种FILO（先进后出）数据结构
![stack](https://upload-images.jianshu.io/upload_images/13187322-a6c72fc90da54062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/451/format/webp)
```c#
stack<int> s;
s.push(1);        //入栈（向栈顶插入元素） 
int a = s.top();  //访问栈顶的元素
s.pop();          //出栈（删除栈顶的元素）
```
### 字符串 `string` `cstring`
```c#
char s;
s = tolower(s);//转为小写
s = toupper(s);//转为大写
	
#include<string>
string str;
for(int i = 0;i < str.length();i++) //str.length()等价于str.size()等价于cstring里的strlen(str)
	str[i] = tolower(str[i]); //转为小写
	str[i] = toupper(str[i]); //转为大写
```
[string头文件](https://zh.cppreference.com/w/cpp/string/basic_string)包含基础的函数
```c#
#include<string>  	//列出如下常用函数
for (auto it = s.begin(); it != s.end(); ++it)  //begin指向首字符，end指向末尾'\n'
	*it = toupper(*it);

str.empty();                                    //判断是否为空，即是否 begin() == end()，返回布尔值

str.insert(int p0, const char *s);         //在p0位置插入字符串s
str.insert(int p0, const char *s, int n);  //在p0位置插入字符串s的前n个字符

str.erase(iterator pos);                   //删除pos处的一个字符
str.erase(iterator pos, int n);            //删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
str.erase(iterator first, iterator last);  //删除从first到last之间的字符
str.clear();                               //如同通过执行 erase(begin(), end())，移除所有字符

int find(char c, int pos = 0);             //从pos开始查找字符c在当前字符串的位置（注：从后往前查找用rfind）
int find(const char *s, int pos= 0);       //从pos开始查找字符串s在当前串中的位置

str.replace(iterator first, iterator last, const char *s);//把[first,last）之间的部分替换为字符串s

str2 = str1.substr(pos,n);                 //返回子串 [pos, pos+count)

//各种转换为string:
str = to_string(value);                          //这里的value可以为int、long long、float、double等

//但是char转string比较特殊:
char c; string str;
stringstream stream << c;
str = stream.str();
```
[cstring头文件](https://zh.cppreference.com/w/cpp/header/cstring)包含进阶的函数，另外还有[cctype头文件](https://zh.cppreference.com/w/cpp/header/cctype)各种布尔函数，这里就不写了
```c#
#include<cstring>  //列出如下常用函数原型
int strcmp( const char *lhs, const char *rhs ); //实际原理是*lhs和*rhs字典值相减
char* strcpy( char* dest, const char* src );    //将后者复制给前者
char* strcat( char* dest, const char* src );    //将后者放在前者尾部，并返回前者
char* strchr( char* str, int ch );              //在str所指向的字节字符串中寻找字符ch的首次出现。认为终止空字符是字符串的一部分，而且若搜索 '\0' 则能找到它。
char* strstr( char* str, const char* target );  //在str所指的字节字符串中寻找字节字符串 target 的首次出现。不比较空终止字符。
```
### 算法库 `algorithm`
```c#
min(a, b);  //返回a与b的较小者
max(a, b);  //返回a与b的较大者
swap(a, b); //交换a与b的值，无返回值
int minx = *(min_element(a,a+n));//返回数组的最小值
int maxx = *(max_element(a,a+n));//返回数组的最大值
```
find查找
```c#
//返回指向首个满足条件的迭代器，或若找不到这种元素则为last
vector<int> v{0, 1, 2, 3, 4}; 
int n = 3;
auto result = find(begin(v), end(v), n);
if (result != end(v)) cout<<"yes";
```
sort排序
```c#
//以升序排序范围[first, last)中的元素，不保证维持相等元素的顺序
sort(v.begin(), v.end());  

//用lambda表达式排序,此处给了降序的例子
sort(v.begin(), v.end(), [](int a, int b) {  
	return b < a;   
});

//自定义比较函数
bool cmp(const student& a,const student& b){
	if(a.score<b.score)
		return true;
	return false;
}
sort(v.begin(), v.end(), cmp);
```
### 正则表达式 `regex`

regex_match：匹配整个字符序列
```c#
regex re("\\d{3}-\\d{8}|\\d{4}-\\d{7}");        // fixed telephone
vector<string> str{ "010-12345678", "0319-9876543", "021-123456789"};
bool ret = regex_match(str, re);
```
regex_search：匹配字符子序列
```c#
string pattern{ "http|hppts://\\w*$" };         // fixed url
regex re(pattern);
vector<string> str{ "http://blog.csdn.net/fengbingchun", "https://github.com/fengbingchun",
					"abcd://124.456", "abcd https://github.com/fengbingchun 123" };
bool ret = regex_search(str, re);
```
regex_replace:匹配整个并都替换
```c#
string pattern{ "\\d{18}|\\d{17}X" };          // fixed id card
regex re(pattern);
vector<std::string> str{ "123456789012345678", "abcd123456789012345678efgh","abcdefbg", "12345678901234567X" };
string fmt{ "********" };
string ret = std::regex_replace(str, re, fmt);
```
常用的元字符：

	“^”：匹配输入字符串的开始位置，不匹配任何字符，要匹配”^”字符本身，需使用”\^”；
	“$”：匹配输入字符串的结尾位置，不匹配任何字符，要匹配”$”字符本身，需使用”\$”；
	“|”：将两个匹配条件进行逻辑"或"(Or)运算,如正则表达式”(him|her)；
	
	“*”： 零次或多次匹配前面的字符或子表达式，”*”等效于”{0,}”，如”\^*b”可以匹配”b”、”^b”、”^^b”、…；
	“+”： 一次或多次匹配前面的字符或子表达式，等效于”{1,}”，如”a+b”可以匹配”ab”、”aab”、”aaab”、…；
	“?”： 零次或一次匹配前面的字符或子表达式，等效于”{0,1}”，如”a[cd]?”可以匹配”a”、”ac”、”ad”；
	
	“\”： 将下一字符标记为特殊字符、文本、反向引用或八进制转义符，如，”n”匹配字符”n”,”\n”匹配换行符，序列”\\”匹配”\”,”\(“匹配”(“；
	“\w”：匹配字母或数字或下划线；“\W”：匹配任意不是字母、数字、下划线的字符；
	“\s”：匹配任意的空白符，包括空格、制表符、换页符等空白字符的其中任意一个，与”[ \f\n\r\t\v]”等效；“\S”：同理相反
	“\d”：匹配数字，任意一个数字，0~9中的任意一个，等效于”[0-9]”；“\D”：匹配任意非数字的字符，等效于”[^0-9]”；
	“\b”： 匹配一个字边界，即字与空格间的位置，也就是单词和空格之间的位置，不匹配任何字符，如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"；“\B”非字边界匹配,"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"；
	
	“\f”：匹配一个换页符，等价于”\x0c”和”\cL”；
	“\n”：匹配一个换行符，等价于”\x0a”和”\cJ”；
	“\r”：匹配一个回车符，等价于”\x0d”和”\cM”；
	“\t”：匹配一个制表符，等价于”\x09”和”\cI”；
	“\v”：匹配一个垂直制表符，等价于”\x0b”和”\cK”；
	“\cx”：匹配”x”指示的控制字符,如，\cM匹配Control-M或回车符，”x”的值必须在”A-Z”或”a-z”之间,如果不是这样，则假定c就是"c"字符本身；
	
	“{n}”：”n”是非负整数，正好匹配n次，如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配；
	“{n,}”：”n”是非负整数,至少匹配n次,如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有”o”，"o{1,}"等效于"o+"，"o{0,}"等效于"o*"；
	“{n,m}”：”n”和”m”是非负整数，其中n<=m，匹配至少n次，至多m次，如，"o{1,3}"匹配"fooooood"中的头三个o，'o{0,1}'等效于'o?'，注意,不能将空格插入逗号和数字之间；如”ba{1,3}”可以匹配”ba”或”baa”或”baaa”；
	
	“x|y”：匹配”x”或”y”，如，”z|food”匹配"z"或"food"；”(z|f)ood”匹配"zood"或"food"；
	“[xyz]”：字符集，匹配包含的任一字符，如，"[abc]"匹配"plain"中的"a";
	“[^xyz]”：反向字符集，匹配未包含的任何字符，匹配除了”xyz”以外的任意字符，如，"[^abc]"匹配"plain"中的"p"；
	
	“[a-z]”：字符范围，匹配指定范围内的任何字符，如，"[a-z]"匹配"a"到"z"范围内的任何小写字母；
	“[^a-z]”：反向范围字符，匹配不在指定的范围内的任何字符，如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符；
	
	“( )”：将”(“和”)”之间的表达式定义为”组”group，并且将匹配这个表达式的字符保存到一个临时区域,一个正则表达式中最多可以保存9个，它们可以用”\1”到”\9”的符号来引用；
	
	“(pattern)”：匹配pattern并捕获该匹配的子表达式，可以使用$0…$9属性从结果”匹配”集合中检索捕获的匹配；
	“(?:pattern)”：匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配，这对于用”or”字符” (|)”组合模式部件的情况很有用, 如，”industr(?:y|ies)”是比”industry|industries”更简略的表达式；
	“(?=pattern)”： 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始；
	“(?!pattern)”： 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"；
	
	要匹配某些特殊字符，需在此特殊字符前面加上”\”：
	如要匹配字符”^”、”$”、”()”、”[]”、”{}”、”.”、”?”、”+”、”*”、”|”，需使用” \^”、” \$”、” \ (“、”\)”、” \ [“、”\]”、” \{“、”\}”、” \.”、” \?”、” \+”、” \*”、” \|”。

### 二叉树遍历

1.定义与创建
```c#
#include <iostream>
#include <string>
#include <queue>
#include <stack>
using namespace std;

string str;
int i;

struct TreeNode{
	char val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(char x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* createTree(){
	char c = str[i++];
	if(c =='#') return NULL;
	TreeNode *root = new TreeNode(c);
	root->left  = createTree();
	root->right = createTree();
}
```

2.递归遍历
```c#
void preVisit(TreeNode *root){
	if(!root) return;
	cout<< root->val << " ";
	preVisit(root->left);
	preVisit(root->right);
}

void midVisit(TreeNode *root){
	if(!root) return;
	midVisit(root->left);
	cout<< root->val << " ";
	midVisit(root->right);
}

void postVisit(TreeNode *root){
	if(!root) return;
	postVisit(root->left);
	postVisit(root->right);
	cout<< root->val << " ";
}
```

3.非递归遍历
```c#
void preVisit2(TreeNode *root){
	if(!root) return;
	TreeNode *p = root;
	stack<TreeNode *> s;
	while(p || !s.empty()){
		if(p){
			cout<< p->val << " ";
			s.push(p);
			p = p->left;
		}
		else{
			p = s.top();
			s.pop();
			p = p->right;
		}
	}
}

void midVisit2(TreeNode *root){
	if(!root) return;
	TreeNode *p = root;
	stack<TreeNode *> s;
	while(p || !s.empty()){
		if(p){
			s.push(p);
			p = p->left;
		}
		else{
			p = s.top();
			cout<< p->val << " ";
			s.pop();
			p = p->right;
		}
	}
}

void postVisit2(TreeNode *root){
    if(!root) return;
    stack<TreeNode *> s;
    TreeNode *cur;       //当前结点 
    TreeNode *pre=NULL;  //前一次访问的结点 
    s.push(root);
    while(!s.empty())
    {
        cur=s.top();
        if( (cur->left && !cur->right) || (pre && (pre==cur->left||pre==cur->right)) ){
            cout<< cur->val << " ";  //如果当前结点没有孩子结点或者孩子节点都已被访问过 
            s.pop();
            pre=cur; 
        }
        else{
            if(cur->left ) s.push(cur->left );
            if(cur->right) s.push(cur->right);
        }
    }    
}
```

4.层次遍历
```c#
void hieVisit(TreeNode *root){
	if(!root) return;
	TreeNode *temp; //保存队列出队时的临时变量
	queue<TreeNode *> q;
	q.push(root);
	while(!q.empty()){
		temp = q.front();
		q.pop();
		cout<< temp->val << " ";
		if(temp->left ) q.push(temp->left);
		if(temp->right) q.push(temp->right);
	}
}
```

5.卡特兰数

给出一个n，求1-n能够得到的所有二叉搜索树
![卡特兰数](https://upload-images.jianshu.io/upload_images/13187322-e3c4b25d79ad0b36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/245/format/webp)
```c#
int numTrees(int n) {  
	vector<int> count(n+1, 0);  
	count[0] =1;  
	count[1] =1;  
	for(int i = 2; i <= n; i++){  
		for(int j = 0; j < i; j++){  
			count[i] += count[j]*count[i-j-1];   
		}  
	}  
	return count[n];  
}  
```


