---
layout:     post
title:      C++字符串题型
subtitle:   For 笔试
date:       2018-08-21
author:     Jiayue Cai
header-img: img/post-bg-arch_linux.png
catalog: true
tags:
    - C++

---


> Last updated on 2018-08-21...

字符串常用技巧：
- int table[256]={0}; table[s[i]] = i; 标记字符最新的位置（eg.无重复字符的最长子串）
- vector<vector<int>> pos(128) 标记各单词中字符出现位置
- unordered_map<char,int> 计数
- unordered_set<char> punctuations = {'!','?',',','\',';','.'} 去标点
- stringstream ss(str)分词
- reverse(s.begin(), s.end()) 反转字符串（左开右闭，即不包括end）
- int left = 0, right = s.size()-1 对撞指针

### 字典序全排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。

例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。

#### 不带重复元素的递归方法

分别将每个位置交换到最前面位，之后全排列剩下的位。

```c#
//调用示例：string s = "abc"; permutation1(s, 0);
void permutation1(string s, int begin){
	if(s.length()-1 == begin) cout<<s<<endl;
	else{
		for(int i=begin;i<s.length();i++){
			swap(s[begin],s[i]);
			permutation1(s,begin+1);
		}
	}
}
```

#### 带重复元素的递归方法

比上面的方法多个判断前缀是否与当前s[i]重复。

```c#
//调用示例：string s = "abc"; permutation2(s, 0);
bool isRepeat(string s,int begin,int end){
    for(int i=begin;i<end;i++)
        if(s[end]==s[i]) return true;
    return false;
}

void permutation2(string s, int begin){
	if(s.length()-1 == begin) cout<<s<<endl;
	else{
		for(int i=begin;i<s.length();i++){
			if(!isRepeat(s,begin,i)){
				swap(s[begin],s[i]);
				permutation2(s,begin+1);
			}
		}
	}
}
```

#### 不带重复元素的非递归方法

> 参考http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html%C2%A0

```
例如：p=839647521是数字1～9的一个排列。下面生成下一个排列的步骤如下：
- 自右至左找出排列中第一个比右边数字小的数字4
- 在该数字后的数字中找出比4大的数中最小的一个5
- 将5与4交换，得到839657421
- 将7421反转，得到839651247。这就是排列p的下一个排列。
```

归纳为：`一找`、`二找`、`三交换`、`四翻转`。
- 从尾部往前找第一个s[i]<s[i+1]的数，位置标为fromIndex
- 从fromIndex位置往后找到最后一个大于s[fromIndex]的数，位置标为changeIndex
- 交换位置fromIndex和changeIndex的值
- 倒序fromIndex位置后的所有数据

```c#
//调用示例：string s = "abc"; permutation3(s);

void permutation3(string s){
	if(s=="") return;
	sort(s.begin(),s.end());
	int fromIndex, endIndex, changeIndex;
	int len = s.length();
	while(true){
		cout<<s<<endl;
		fromIndex = endIndex = len - 1;
        while (fromIndex > 0 && s[fromIndex] < s[fromIndex - 1]) --fromIndex;
        if (fromIndex == 0) return;
        changeIndex = fromIndex;
        while (changeIndex + 1 < len && s[changeIndex + 1] > s[fromIndex - 1]) ++changeIndex;
        swap(s[fromIndex - 1], s[changeIndex]);   
        reverse(s.begin()+fromIndex,s.end());
	}
}
```

### 组合问题

#### 使用位运算

题目：输入一个字符串，输出该字符串中字符的所有组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。

思路：一个长度为n的字符串，它的组合有2^n-1中情况，我们用1 ~ 2^n-1的二进制来表示，每种情况下输出当前位等于1的字符。
![](/img/post/20180821/1.png)

```c#
//调用示例；char str[] = "abc"; Combination(str);
void Combination(char *str){
	int len=strlen(str); 
	for(int cur=1; cur < (1<<len); cur++){    //遍历所有的情况，1<<len就等于2^len，遍历1 ~ 2^len-1
		for(int j=0; j < len; j++){           //遍历所有的字符
			if(cur & (1 << j))                //判断哪一位为1，即输出该位
				cout << str[j]; 
		}
		cout << endl;  //一种情况结束
	}
}
```
