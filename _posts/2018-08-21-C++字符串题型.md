---
layout:     post
title:      C++字符串题型
subtitle:   For 笔试
date:       2018-08-21
author:     Jiayue Cai
header-img: img/post-bg-arch_linux.png
catalog: true
tags:
    - C++

---


> Last updated on 2018-08-21...

字符串常用技巧：
- int table[256]={0}; table[s[i]] = i; 标记字符最新的位置（eg.无重复字符的最长子串）
- vector<vector<int>> pos(128) 标记各单词中字符出现位置
- unordered_map<char,int> 计数
- unordered_set<char> punctuations = {'!','?',',','\',';','.'} 去标点
- stringstream ss(str)分词
- reverse(s.begin(), s.end()) 反转字符串（左开右闭，即不包括end）
- int left = 0, right = s.size()-1 对撞指针

### 字典序全排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。

例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。

#### 不带重复元素的递归方法

分别将每个位置交换到最前面位，之后全排列剩下的位。

```c#
//调用示例：permutation1(s, 0)
void permutation1(string s, int begin){
	if(s.length()-1 == begin) cout<<s<<endl;
	else{
		for(int i=begin;i<s.length();i++){
			swap(s[begin],s[i]);
			permutation1(s,begin+1);
		}
	}
}
```

#### 带重复元素的递归方法

比上面的方法多个判断前缀是否与当前s[i]重复。

```c#
//调用示例：permutation2(s, 0)
bool isRepeat(string s,int begin,int end){
    for(int i=begin;i<end;i++)
        if(s[end]==s[i]) return true;
    return false;
}

void permutation2(string s, int begin){
	if(s.length()-1 == begin) cout<<s<<endl;
	else{
		for(int i=begin;i<s.length();i++){
			if(!isRepeat(s,begin,i)){
				swap(s[begin],s[i]);
				permutation2(s,begin+1);
			}
		}
	}
}
```

#### 非递归方法

> 参考http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html%C2%A0

归纳为：`一找`、`二找`、`三交换`、`四翻转`。
- 从尾部往前找第一个s[i]<s[i+1]的位置标为i
- 从i位置往后找到最后一个大于s[i]的数标为m
- 交换位置i和m的值
- 倒序i位置后的所有数据
- 便得到了字典序临近的下一个字符串

```
例如：p=839647521是数字1～9的一个排列。下面生成下一个排列的步骤如下：
- 自右至左找出排列中第一个比右边数字小的数字4
- 在该数字后的数字中找出比4大的数中最小的一个5
- 将5与4交换，得到839657421
- 将7421反转，得到839651247。这就是排列p的下一个排列。
```

```c#
//调用示例：permutation3(s)
void reverse(string s, int k){
	if(s=="" || s.length()<=k) return;
	int len = s.length();
	for(int i=0; i<(len-k)/2; i++){
		int m = k+i;
		int n = len-1-i;
		if(m<=n){
			swap(s[m],s[n]);
		}
	}
}

void permutation3(string s){
	if(s=="") return;
	sort(s.begin(),s.end());
	cout<<s<<endl;
	int len = s.length();
	while(true){
		int l = len-1;
		int r;
		while(l>=1 && s[l-1]>=s[l]) l--;
		if(l==0) break;
		r=l;
		while(r<len && s[r]>s[l-1]) r++;
		swap(s[l-1],s[r-1]);
		reverse(s,l);
		cout<<s<<endl;
	}
	return;
}
```

#### 使用位运算求组合问题

一个长度为n的字符串，它的组合有2^n-1中情况，我们用1 ~ 2^n-1的二进制来表示，每种情况下输出当前位等于1的字符。
![](/img/post/20180821/1.png)
```c#
void Combination(char *str){
	int len=strlen(str); 
	for(int cur=1; cur < (1<<len); cur++){    //遍历所有的情况，1<<len就等于2^len，遍历1 ~ 2^len-1
		for(int j=0; j < len; j++){           //遍历所有的字符
			if(cur & (1 << j))                //判断哪一位为1，即输出该位
				cout << str[j]; 
		}
		cout << endl;  //一种情况结束
	}
}
```
